= javascript语言精粹 读书笔记 =
lds <lds2012@gmail.com>
{localdate}


.遗留问题
**************************************************************************
- javascript权威指南5版 8.8.1 词法作用域
- 函数式编程 lambda
- 附录B 鸡肋部分
- 附录C jslint提供了严谨性
- 铁路图，语法图syntax diagrams
- throw
- 对象字面量的prototype
- p53不懂
- 第4章后半部分
- p86 函数化模式 未理解透彻
**************************************************************************


== 序言 ==

此书虽薄，但需反复阅读。


== 精华 ==

javascript有精华的部分，也有糟糕的部分，但你有权利定义你的子集，只使用精华的部分。

本书不全面介绍javascript的所有部分，只强调精华的部分，并提示避免糟糕的部分。

NOTE: 因先入为主以及每个人使用javascript可能已经形成一定的习惯或模式，导致想要改变其中糟糕的一部分会是很困难的。忘掉有时比记住更难。

=== 分析javascript ===

javascript建立在一些好的想法和少数坏的想法上。

- 好的想法有：
  * 函数
  * 弱类型
  * 动态对象
  * 一个富有表现力的对象字面量表示法
  * ...

- 坏的想法有
  * 基于全局变量的编程模型
  * ...


.好想法：
  - 词法作用域::
    javascript是披着C外衣的Lisp。
  - 弱类型::
    自由。
  - 对象字面量表示法::
    json灵感来源。
  - 原型继承::
    javascript有一个无类别(class-free)对象系统，对象直接从其他对象继承属性。

.坏想法：
  - 全局变量::
    依赖全局变量来进行连接，所有编译单元的所有顶级变量被撮合到一个被称为全局对象的公共命名空间中。
    全局变量是魔鬼。


NOTE: 避免一些模棱两可的情况，它们会带来风险和麻烦事。

NOTE: 熟练掌握javascript后会发现函数式编程是一件很有趣的事。

=== 一个简单的试验场 ===
无


== 语法 ==

=== 空白 ===

建议避免使用`/* */`方式的注释，因为在正则表达式的字面量中可以会出现。

=== 标识符的 ===

不允许在对象名，参数，对象字面量，一个属性存取表达式的点号之后，使用保留字作为对象的属性名。

=== 数字 ===

只有单一的数字类型，在内部被表示为64位的浮点数。

`NaN`::
not a number

`Infinity`::
所有大于`1.79769313486231570e+308`的值。

=== 字符串 ===

javascript中的所有字符都是16位的`Unicode`.

`\u0041`这种表达方法,表示字符码位。

字符串有一个`length`属性。

字符串是不可变的。

=== 语句 ===

一个编译单元包含一组可执行的语句，在web浏览器中，每个`<script>`标签都提供一个被编译且立即执行的编译单元。因为缺少连接器，javascript把它们一起抛入一个公共的全局名字空间中。

在函数内部使用`var`定义变量，则该变量是这个函数的私有变量。

代码块是包在一对花括号中的一组语句。代码块不像其他语言，它不会创建一个新的作用域。

以下值被当作假(`false`):
------------------------------------------
false,null,undefined,'',0,NaN
------------------------------------------
其他值都被当作真(`true`).

.`for in`
枚举一个对象的所有属性名。

.`typeof`
---------------------------------------
typeof null;//"object"
typeof [1,2];//"object"
---------------------------------------

== 对象 ==

- 简单类型：
  * 数字
  * 字符串
  * 布尔值
  * null
  * undefined.
- 其他所有值都是对象。

javascript中的对象是可变的键控集合(`keyed collections`).

*对象*是属性的容器。

- 属性名可是包括空字符串在内的任意字符串。
- 属性值可以是除`undefined`值之外的任意值。

javascript中的对象是无类别(`class-free`)的.

=== 检索 ===

[source,javascript]
--------------------------------------------
fligth['status']
fligth.status
--------------------------------------------
两种形式皆可，但优先使用后者。

尝试检索一个并不存在的成员元素的值，返回`undefined`.

[source,javascript]
--------------------------------------------------
fligth.equipment // undefined
--------------------------------------------------

填充默认值

[source,javascript]
--------------------------------------------------
var status = fligth.status || 'unknown';
--------------------------------------------------

尝试检索一个`undefined`属性会抛出`TypeError`异常，避免可用：

[source,javascript]
-------------------------------------------------------------
fligth.equipment       // undefined
filgth.equipment.model // throw "TypeError"
fligth.equipment && fligth.equipment.model // undefined
-------------------------------------------------------------

=== 引用 ===

对象是通过*引用传递*，它们永远不会被拷贝('值传递')。

=== 原型prototype ===

[source,javascript]
--------------------------------------------------

if (typeof Object.beget !== 'function') {
	Object.beget = function (o) {
		var F = function(){};  
		F.prototype = o;
		return new F();
	};
}

--------------------------------------------------

原型链接在修改对象时不起作用，当我们对某个对象作出改变时，不会触及该对象的原型。

原型链接只有在检索值时才被用到，如果我们尝试去获取对象的某个属性值，且该对象没有此属性名，那么javascript会试着从原型对象中获取属性值。如果那个原型对象也没有该属性，那么再从它的原型中寻找，以此类推，直到找到为止，若最终也未找到则返回`undefined`。这个过程成为*委托*。

原型关系是一种'动态'的关系，一旦修改原型，则使用该原型的对象即时可见修改结果。

=== 反射 ===

- typeof
- hasOwnProperty(不检查原型链)

=== 删除 ===

`delete`运算符可以用来删除对象的属性，不会触及原型链。

=== 减少全局变量污染 ===

.方法1

只创建一个全局变量

[source,javascript]
----------------------
var MYAPP = {};
----------------------

将其作为所有应用的容器。相当于命名空间。

.方法2

闭包。


== 函数 ==


=== 函数对象 ===

函数就是*对象*。

*对象*是“名/值”对的集合，并拥有一个连到原型对象的隐藏链接。

对象字面量产生的对象连接到`Object.prototype`.

函数对象连接到`Function.prototype`（该原型对象本身又连接到`Object.prototype`)。

每个函数在创建时附有两个附加的隐藏属性：
- 函数的上下文
- 实现函数行为的代码。

函数的与众不同在于它们可以被调用。

=== 函数字面量 ===

[source,javascript]
----------------------------------
var add = function (a,b) {
	return a + b;
};
----------------------------------

=== 调用 ===

调用一个函数将暂停当前函数的执行，传递控制权和参数给新函数。

每个函数接收两个附加的参数:
- `this`
- `arguments`

Javascript中有四种调用模式：
- 方法调用模式
- 函数调用模式
- 构造器调用模式
- apply调用模式。

.方法调用模式

当一个函数被保存为对象的一个属性时，我们称它为一个*方法*。当一个方法被调用时，`this`被绑定到该对象。
  
[source,javascript]
--------------------------------------------------

var Obj = {
	name    : "lds",
	getName : function(){ alert(this.name); }
}; 

Obj.getName();

--------------------------------------------------

`this`到对象的绑定发生在调用的时候，这个超级迟绑定（`very late binding`)使得函数可以对`this`高度复用。

通过`this`可取得它们所属对象的上下文的方法称为*公共方法*。

.函数调用模式

当一个函数并非一个对象的属性时，那么它被当作一个函数来调用。`this`被绑定到全局对象。

[source,javascript]
-----------------------------
var sum = add(3,4);
-----------------------------

当内部函数被调用时，`this`依然绑定到全局对象，而非外部函数的`this`变量，这是一个语言设计错误。为避免可使用：

[source,javascript]
-----------------------------------------------------------------------

myObject.double = function () {
	//预先储存外部函数的this指针，利用闭包特性，内部函数可访问该变量。
	var that = this; 

	var helper = function () {
		that.value = add(that.value, that.value);
	};

	helper(); //以函数的形式调用
};

//以方法的形式调用
myObject.double();

-----------------------------------------------------------------------

.构造器调用模式

javascript是一门基于*原型继承*的语言（大多数语言都是基于类的语言）。尽管原型继承有着强大的表现力，但它并不被广泛理解。javascript本身对其原型的本质也缺乏信心，所以它提供了一套和基于类的语言类是的对象构建语法。


[source,javascript]
---------------------------------
var que = new Que();
---------------------------------

.Apply调用模式

javascript是一门'函数式'的面向对象编程语言，所以函数可以拥有方法。

`apply`方法接受两个参数
. 将被绑定给`this`的值
. 参数数组。

[source,javascript]
------------------------------------------------------------------------

var statusObject = {
	status: 'A-OK'
};

//statusObject并没有继承自Que.prototype,但我们可以在statusObject上调用Que.prototype.get_status方法，尽管statusObject并没有一个名为get_status的方法。

var status = Que.prototype.get_status.apply(statusObject);
//status值为'A-OK'.

------------------------------------------------------------------------

=== 参数 ===

当函数被调用时，会附送一个参数`arguments`伪数组（array-like,拥有`length`属性，但缺少所有的数组方法）。

=== 返回 ===

一个函数总会返回一个值，如果没有指定返回值，则返回`undefined`.

如果函数以在前面加上`new`前缀的方式来调用，且返回值不是一个对象，则返回`this`(该新对象).

=== 异常 ===

`throw`语句中断函数的执行，抛出一个`Exception`对象，该对象包含可识别异常类型的`name`属性和一个描述性的`message`属性。也可添加其他的属性。

[source,javascript]
-----------------------------------------

throw {
	name    : 'TypeError',
	message : 'add needs numbers'
};

-----------------------------------------

在`catch`中检查异常的`name`属性以确定异常的类型。

=== 给基本类型增加方法 ===

可以给`Object`，`Array`添加方法。

[source,javascript]
---------------------------------------------------------

Function.prototype.method = function(name, func) {
	if (!this.prototype[name]) {
		this.protoype[name] = func;
		return this;
	}
};

Stringl.method('trim', function() {
	return this.replace(^\s+|\s+$/g, '');
});

---------------------------------------------------------

=== 递归 ===

*递归函数*是会直接或间接地调用自身的一种函数。

=== 作用域 ===

javascript有'函数作用域'，没有'代码块作用域'（一对花括号之间）。

=== 闭包 ===

[source,javascript]
---------------------------------------------------------------------------

var myObject = function () {
	var value = 0; //利用函数作用域保护该值。

	return {
		increment: function (inc){},
		getValue: function(){return value}
	}
}();  //注意此处的括号，它将使myObject不是一个函数，而是函数执行后的结果。

---------------------------------------------------------------------------

母函数即使已经返回，但只要其中的变量被其子函数使用，那么该变量会持续保留。

[source,javascript]
------------------------------------------------------------------------

String.method('deentityify', function() {
	var entity = { 
        quot: '"',
        it: '<',
        gt: '>'
    };
    
    //真正的deentityify方法
    return function () {
		return this;//省略
    };
    //立即调用
    }()   );

------------------------------------------------------------------------

=== 回调 ===
无

=== 模块 ===

*模块*是一个提供接口却隐藏状态与实现的函数或对象。

通过使用函数去产生模块，完全摒弃全局变量的使用。

模块模式的一般形式是：
. 一个定义了私有变量和函数的函数.
. 利用闭包创建可以访问私有变量和函数的特权函数.
. 最后返回这个特权函数，或者把它们保存到一个可以访问的地方。

[source,javascript]
--------------------------------------------------------------

var serial_maker = function () {
    //私有变量
    var _prefix = '';
    var _seq    = 0;
    
    //返回新对象，包含特权函数（唯一可访问私有变量的函数）
    return {
        set_prefix: function (p) {
                        _prefix = String(p);
                    },
        gensym: function () {
                    var result = _prefix + _seq;
                    _seq += 1;
                    return result;
                }
    };
};//end serial_maker

---------------------------------------------------------------

=== 级联 ===

返回`this`，可实现:

[source,javascript]
----------------------------------
Obj.move(350,150).width(100);
----------------------------------

=== 套用 ===
无

=== 记忆 ===

函数可以用对象去记住先前操作的结果，从而能避免无谓的运算。这种优化被称为*记忆*（`memoization`).

[source,javascript]
-------------------------------------------------------------------

var fibonacci = function () {
    //记忆储存器
    var memo = [0,1];

    //真正的fibonacci函数
    var fib  = function (n) {
        var result = memo[n];
        //检查记忆储存器中是否存在结果，不存在才计算
        if (typeof result !== 'number') {
            result  = fib(n - 1) + fib(n - 2);
            memo[n] = result;
        }
       return result;
    };
   return fib;
//利用闭包返回特权函数，需要立即执行
//如果是返回对象，则不需要，直接return对象即可。
}(); 

--------------------------------------------------------------------


== 继承 ==


javascript可以模拟那些基于类的模式，同时它也可以支持其他更具表现力的模式。

在基于类的语言中，对象是类的实例，并且类可以从另一个类继承。javascript是一门基于*原型*的语言，这意味着对象直接从其他对象继承。

=== 伪类 ===

javascript的原型存在着诸多矛盾，某些看起来有点像基于类的语言的复杂语法问题遮蔽了它的原型机制。它不容对象直接从其他对象继承，反而插入了一个多余的间接层，从而使构造器函数产生对象。

当一个函数对象被创建时，`Function`构造器产生的函数对象会运行类似的代码：

[source,javascript]
-----------------------------------------------
this.prototype = {constructor: this};
-----------------------------------------------

新函数对象被赋予一个`prototype`属性，其值是包含一个`constructor`属性且属性值为该新函数对象。该`prototype`对象是存放继承特征的地方。

NOTE: javascript没有去确定哪些函数以打算用来做构造器的，所有每个函数都会有一个`prototype`对象。

[NOTE]
在调用构造器函数是如果没有加上`new`前缀，那么构造器中的`this`将不会被绑定在新对象，而是绑定在'全局对象'上，从而破坏全局变量，而且也不会造成编译警告和运行警告。这是一个严重的语言设计错误。避免这个问题，有两个方法：全部构造器函数都约定首字大写；不使用`new`。


“伪类”形式可以从不熟悉javascript的程序员提供便利，但它也隐藏了该语言的真实本质。在基于类的语言中，类的继承是代码重用的唯一方法。javascript有着更多且更好的选择。

=== 对象说明符 ===

避免一大串参数，无法记住其顺序，可使用`JSON`对象作为参数传递给构造器函数。


=== 原型prototype ===

在一个纯粹的原型模式中，我们会摒弃类，转而专注于对象。基于原型的继承相比基于类的继承在概念上更为简单：一个新对象可以继承一个旧对象的属性。可以理解为：你通过改造一个有用的对象开始，接着可以构造更多和那个对象类似的对象。

[source,javascript]
------------------------------------------

var myMamal = {
       name     : 'liu',
       get_name : function () {
           return this.name;
       }
};

var myCat = Object.beget(myMammal);
myCat.name = 'ding';
myCat.age  = 23;
myCat.get_age = function () {
    return this.age;
};

-------------------------------------------

这是一种“*差异化继承*”。通过定义一个新的对象，我们指明了它与所基于的基本对象的差别。

=== 函数化 ===

利用模块模式，得到私有变量和私有函数。

.伪代码模板：

[source,javascript]
------------------------------------------------

var constructor = function(spec, my) {
    var that,其他的私有实例变量；
    my = my || {};

    把共享的变量和函数添加到my中

    that = 一个新对象

    添加给that的特权方法

    return that;
}

------------------------------------------------

.实例：

[source,javascript]
------------------------------------------------

var mammal = function (spec) {
    var that = {};

    that.get_name = function () {
        return spec.name;
    };

    that.says = function () {
        return spec.saying || '';
    };

    return that;
};

var myMammal = manmal({name: 'herb'});

//继承
var cat = function (spec) {
    spec.saying = spec.saying || 'meow';
    //继承
    var that = mamal(spec);
    that.get_name = function () {
        return that.says();
    };
    return that;
};

--------------------------------------------------

函数化模式提供了一个处理父类方法的办法：

[source,javascript]
--------------------------------------------------

Object.method('superior', function (name) {
        var that   = this,
            method = that[name];
        return function () {
            return method.apply(that, arguments);
        };
});

---------------------------------------------------

5.5 部件
